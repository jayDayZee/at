# @ (at)

@ is a programming language  
@ only exists in runtime  
@ is a tip of the hat to the programming language "a" (granddaddy to "c"), but inside a visible circle.  
  
the concept of source code is a tip of the hat to the material (paper, stone) languages that have formed the basis for cross generational language. Core to the concept of Language is "predictability over time". Stone and Paper provide this by being a medium in physics that does not change configuration over tens to thousands of years. Cross generational language is the first tool that distantly out paced genetic evolution as a tool for change. This is why it should be tipped a hat to.  
  
Source Code is not required to define formal systems (software)  
  
Source Code is the invention of Jon Von Neuman.  
Before von Neuman, computers were "programmed" by connecting switches with patch cables (guitar cables)  
Alexander Turing and Jon von Neuman are brothers in futures.  
Jon von Neuman designed the modern micro processor.  
Jon von Neuman invented the idea that if you implement a single Turing complete machine you never have to rewire the cables. This is the reason we have been able to microtize the microprocessor  
Before Jon von Neuman there was one "data flow" into the computer. After von Neuman, there are two, the "data" flow and the "control" flow.  

# Step 1

It is possible to take a second step along the road the Jon von Neuman forged.
After the first step, software designers (coders) have access to one Turing Complete machine, into which they must convert their internal model of a system.
Systems implementation can be divided into three stages
* Work 1:
  * Fully conscious model building (lets not even try and address that)
* Work 2:
  * Conversion to a grounded implementation design (this requires experience, for example, implementing a sorting algorithm that is exponential or linear with n, depending on the Way the algorithm is implemented. 
  * Work 2 leverages **experience** in implementation, where Work 1 leverages experience of the target domain and creativity.
  * Work 2 is a space where developers collaborate on **design decisions**
 * Work 3
   * Work 3 is the conversion of the output of Work 2 into a linear sequence of ascii characters.
 
Where we refuse to be drawn into an argument as the the "real" meaning of Work 1, we can state with absolute accuracy, that Work 2 must create a structure in the brain that is an isomorphism with [Decidable Space](someURLInTheWiki).

### Decidable space is coined in this paper to be:
* The N dimensional space where each point represents one of the infinite Turing Complete machines.

A Micro Processor is a bare metal physics implementation of One Single Turing Complete Machine
All extant programming languages are designed to ease the interface between the human mind (Work 1) and the final output (Work 3).

## Step 2
The Second Step along the road that von Neuman initially forged is to create a software model of the microprocessor in such a way that Work 3 invoves conversion of the output of Work 2 into any one of the infinite Turing Complete machines.

It is facile to express that:
* If the output of Work 2 is necessarilly decidable
* Then there **must** be a Turing complete machine that is the **same** as the output of Work 2
* Therefore Work 3 shrinks to be negligable
* Currently Work 3 is the most time consuming and error prone part of building software
* Work 3 requires 90+% of the resources and contributes 95% of the bugs of all software development.


## Documentation
Documentation **must** provide a natural language expression of a formal language that enables the learner to build a mental model of the software system engaged with. This is a tipping of that hat towards formal languages


# @
@ is a basis of code formed around a single 70 line function called "traverse" that implements Decidable Space as a programming language


## community
Git hub uses "source code" and "documentation" to form an informal communication channel to communicate formal systems. 
It must be possible to communicate those systems directly in @ primitives, since they **must** be about decidable space.

In the future, there will be a significant runtime space running acrross many cloud and local machines which is shared, where the open source community co-creates representations of core human concepts

## **What** do I implement in @
Words such as:
* Place
* Welcome
* Introduction
* List

A crowdfunding website is a Place (website)
When people arrive at a place they must be to it (youTube video). Without the 




