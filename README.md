# @ (at)

@ is a programming language  
@ only exists in runtime  
@ is a tip of the hat to the programming language "a" (granddaddy to "c"), but inside a visible circle.  
  
the concept of source code is a tip of the hat to the material (singing, paper, stone) languages that have formed the basis for cross generational language. Core to the concept of Language is "predictability over time". Stone and Paper provide this by being a medium in physics that does not change configuration over tens to thousands of years. Cross generational language is the first tool that distantly out paced genetic evolution as a tool for change. This is why it should be tipped a hat to.  
  
Source Code is not required to define formal systems (software)  
  
Source Code is the invention of Jon Von Neuman.  
Before von Neuman, computers were "programmed" by connecting switches with patch cables (guitar cables)  
Alexander Turing and Jon von Neuman are brothers in futures.  
Jon von Neuman designed the modern micro processor.  
Jon von Neuman invented the idea that if you implement a single Turing complete machine you never have to rewire the cables. This is the reason we have been able to microtize the microprocessor  
Before Jon von Neuman there was one "data flow" into the computer. After von Neuman, there are two, the "data" flow and the "control" flow.  

# Step 1

It is possible to take a second step along the road the Jon von Neuman forged.
After the first step, software designers (coders) have access to one Turing Complete machine, into which they must convert their internal model of a system.
Systems implementation can be divided into three stages
* Work 1:
  * Fully conscious model building (lets not even try and address that)
* Work 2:
  * Conversion to a grounded implementation design (this requires experience, for example, implementing a sorting algorithm that is exponential or linear with n, depending on the Way the algorithm is implemented. 
  * Work 2 leverages **experience** in implementation, where Work 1 leverages experience of the target domain and creativity.
  * Work 2 is a space where developers collaborate on **design decisions**
 * Work 3
   * Work 3 is the conversion of the output of Work 2 into a linear sequence of ascii characters.
 
Where we refuse to be drawn into an argument as the the "real" meaning of Work 1, we can state with absolute accuracy, that Work 2 must create a structure in the mind that is an isomorphism with some point in [Decidable Space](someURLInTheWiki).

### Decidable space is coined in this paper to be:
* The N dimensional space where each point represents one of the infinite Turing Complete machines.
* In a well implemented programming language, all points in Decidable Space should be accessible in exactly one step from each other.

A Micro Processor is a bare metal physics implementation of **One Single** Turing Complete Machine  
All extant programming languages are designed to ease the interface between the human mind (Work 2) and the final output (Work 3). They are explicitly tools to manifest linear ascii sequences that are machine convertable into the specific RISC (CISC, etc) implementation on the metal.

## Step 2
The Second Step along the road that von Neuman initially forged is to create a software model of the microprocessor in such a way that Work 3 invoves conversion of the output of Work 2 into any one of the infinite Turing Complete machines.

It is facile to express that:
* If the output of Work 2 is necessarilly decidable
* Then there **must** be a Turing complete machine that is the **same** as the output of Work 2
* Therefore Work 3 shrinks to be negligable
* Currently Work 3 is the most time consuming and error prone part of building software
* Work 3 requires 90+% of the resources and contributes 95% of the bugs of all software development.

# @
* @ is a base of code formed around a single 70 line function called "traverse" that makes Decidable Space directly accessible to the programmer.  
* @ can easily be implemented in any "programming language
* @ is able to upgrade any existing "source code" base into @

## Documentation
Documentation **must** provide a natural language expression of a formal language that enables the learner to build a Work 2 mental model of the desired toolkit. This is a tipping of that hat towards paper. Both the **creation** of documentation and the **grokking** of documentation require effort.

## Interface
* The most facile interface between the programmer and the machine is the edges of the sense / motor nerves of the brain, and the screen (speakers) / keyboard of the computer
* the most valuable definition of "interface" between the programmer and the machine is the edges of Work 2.
* It **must** be possible for the machine to hold runtime objects that directly represent any output of Work 2.
* Therefore it must be possible to write code by requesting whichever Work 2 Object is currently needed in the modelling of the system (for example by pressing a sequence of the 108 buttons on the keyboard, or clicking on some visual artifact with a pointer device, or looking at it with an eye tracker).
* As we write software, we progress through an iterative process
* This iterative process **must** begin at Work 1 and resolve at Work 3
* Between Work 2 and Work 3, all decisions **must** be holdable in Decidable Space, and therefore **must** be holdable as runtime objects within the @ programming language.
* Currently the tools that exist for programming are defined to make it easier to produce Work 3 targetted at the **One Single** Turing Complete machine implemented on the metal.
* A **good** programming language should be defined to represent the output of Work 2 and the iterative decision making that is the active behaviour during design.
* Good programmers can work in Work 2 space.
* @ **must** be able to have a **complete** 1 2 1 correlation with this requirement.

## community
Git hub uses "source code" and "documentation" to manifest an informal communication channel to communicate formal systems. 
It must be possible to communicate those systems directly in @ primitives, since they **must** be about decidable space
*  Press "f" on your keyboard
  * "Hi, I am a for loop, would you like to add your initial state please?"
  * "And now your conditional?"
  * and your iterator
  * now please feel free to enter the code body
* Would you like to rename this variable? Thats fine, it is an object that is expressed on the screen however you would like. Do I understand the scope model of the Work 2 environment I am designed to guide you interactions with? Yes of course I do. Please just update the representation of that variable object to whatever you would like. Find Replace is a paper based paradigm

# The Future
The future of @ will create a significant runtime space running acrross many cloud and local machines which is shared. The open source community will co-create representations of core human concepts. The core concepts will contain many hundreds of hours of developer experience, and will be able to ask questions that guide the expressions of systems.  
It will be easier to program in @ than to draw circles and lines on a piece of paper.  

# The Work of Research
**What** do I implement in @  
  
Words such as:  
* Place
* Welcome
* Introduction
* List

* example
  * A crowdfunding website is a Place (websiteType (physicalType, eventType, etc) )  
  * When people arrive the first time at a place they must be welcomed to your energy style to it (youTube video), graphics style.  
  * Introduction - here is a List of Projects, here is a donationButton, here is a List of Founders, here is List of Principles of the Place. 
    * without Introduction, Places must follow generic guidelines, which makes them generic. Imagine being dropped into the middle of a shopping centre with no map or idea where the food court is. Shopping centres have maps near the doors.
  * What is a Project?
    * a Project is a Place.
    * Welcome (youTube video communicating the energy style of the Project)
    * Introduction - here is the Description, here is the List of Rewards.
      * What is a reward? Welcome, introduction, etc.
 
This is both a description of the user experience and the developers experience.  
@ is an infinite meta language.
  
we should ask the Dalai Lama what words to implement.
